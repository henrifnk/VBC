---
title: "Copula Investigation"
format: html
editor: visual
---

## Set-Up

```{r, warning=FALSE, message=FALSE}
# Visualization
library(grid)
library(gridExtra)
library(GGally)
library(ggplot2)
library(tidyr)
# Bias Correction and Helpers Library
library(MBC)
library(R2D2)
library(rvinecopulib)
library(scam)
# Evaluation
library(caret)
library(parallel)
library(transport)
# Data (from MBC package)
data(cccma)
set.seed(5)
source("R/vine_correct.R")
# subset to three vars
cccma[1:4] = lapply(cccma[1:4], function(x) x[, c(1,2,6)])
cccma[5:6] =  lapply(cccma[5:6], function(x) x[c(1,2,6)])
summary(cccma$gcm.c)
```

# Fit

## Fit MBCn

```{r, warning=FALSE}
begin = Sys.time()
fit.mbcn <- MBCn(o.c=cccma$rcm.c, m.c=cccma$gcm.c,
                 m.p=cccma$gcm.p, ratio.seq=cccma$ratio.seq,
                 trace=cccma$trace, iter = 30, silent = TRUE)
Sys.time() - begin
mbcn.p <- fit.mbcn$mhat.p
mbcn.c <- fit.mbcn$mhat.c
colnames(mbcn.c) = colnames(mbcn.p) <- colnames(cccma$rcm.c)
```

## Fit VBC

### Grid Search for a good multiplier

```{r}
oc = cccma$rcm.c
mc = cccma$gcm.c
mp = cccma$gcm.p
source("R/vine_correct.R")
m_control = list(xmin = c(0, NaN, 0), mult = 1)
# How can we automize this?
c_control_5 = list(family_set = "all", structure = cvine_structure(c(1, 3, 2)), mult = 5)
c_control = list(family_set = "all", structure = cvine_structure(c(1, 3, 2)), mult = 1)
#plot(cvine_structure(c(1, 3, 2)))
begin = Sys.time()
vbc = vine_correct(oc, mc, mp, margins_controls = m_control,
                      copula_controls = c_control)
Sys.time() - begin
vbc_c5 = vine_correct(oc, mc, mp, margins_controls = m_control,
                      copula_controls = c_control_5) 
attr(vbc, "vine_oc")
attr(vbc_c5, "vine_oc")
Sys.time() - begin

```

## Fit R2D2

```{r warning = FALSE}
begin = Sys.time()
ubc = mapply(QDM, o.c = data.frame(oc), m.c = data.frame(mc), m.p = data.frame(mp),
             ratio=cccma$ratio.seq, trace=cccma$trace)
ubc = do.call(cbind, ubc["mhat.p",])
r2d2_BC = r2d2(oc, ubc)
Sys.time() - begin
r2d2_bc= r2d2_BC$r2d2_bc
colnames(r2d2_bc) = colnames(vbc)
```

# Visual Evaluation

## Density and Korrelation

```{r, eval=FALSE, echo=FALSE}
compare_correction = function(data, method, title){
  dta = rbind(
  cbind.data.frame(oc, method = "Measured"),
  cbind.data.frame(data, method = method)
)
dta$method = as.factor(dta$method)

ggpairs(dta, aes(col = method),
        lower = list(continuous = wrap("density", alpha = 0.5, bins = 25, alpha = 0.3)),
        diag = list(continuous = wrap("densityDiag", alpha = 0.5)),
        upper = list(continuous = wrap("cor", method = "kendall")),
        title = title, progress = FALSE)
}

compare_correction(data = rvine(nrow(mp), attr(vbc, "vine")), method = "VineSim",
                   title = "Compare Vine Simulations with Observed data")

compare_correction(data = mbcn.p, method = "MBCN.P",
                   title = "Compare MBCN projection with Observed data")

compare_correction(data = r2d2_bc, method = "r2d2",
                   title = "Compare R2D2 projection with Observed data")



```


```{r}
grab_grid = function(data, title) {
  grid.grabExpr(print(ggpairs(as.data.frame(data),
                                       lower = list(continuous = wrap("density", bins = 30)),
                                       upper = list(continuous = wrap("cor", method = "kendall")),
                                       title = title)))
}



mbc_pair = grab_grid(mbcn.p, "MBCn Correction")
mbc_pair_c = grab_grid(mbcn.c, "MBCn Cali Correction")
vbc_sim_pair = grab_grid(rvine(nrow(mp), attr(vbc, "vine_oc")), "Vine Simulation")
vbc_sim_pair_c5 = grab_grid(rvine(nrow(mp), attr(vbc_c5, "vine_oc")), "Vine Simulation C5")
vbc_pair = grab_grid(vbc, "Vine Correction") 
oc_pair = grab_grid(oc, "Observed Data")
r2_pair = grab_grid(r2d2_bc, "R2D2 Correction")

grid.arrange(oc_pair, vbc_pair)
grid.arrange(oc_pair, vbc_sim_pair)
grid.arrange(oc_pair, vbc_sim_pair_c5)
grid.arrange(oc_pair, mbc_pair)
grid.arrange(oc_pair, mbc_pair_c)
grid.arrange(oc_pair, r2_pair)
```

What about the copula between tas and huss? This is akwardly skewed in huss direction...

## Zeros in Precip

```{r}
sum(oc[, "pr"] == 0)
sum(vbc[, "pr"] == 0)
sum(mbcn.p[, "pr"] == 0)



```

Can we fit the marginals better (zero inflated)?

## From Calibration to Projection Period

```{r}
plot_delta = function(cal, proj, title) {
  long_mc = apply(cal, 2, sort) %>% 
  as.data.frame() %>%
  gather(key = "Variable", value = "Cali")

  long_mp = apply(proj, 2, sort) %>% 
  as.data.frame() %>%
  gather(key = "Variable", value = "Proj")
  
  df = cbind(long_mc, "Proj" =long_mp$Proj)
  
  ggplot(df, aes(x = Cali, y = Proj)) +
    geom_point(alpha = 0.7) +
    #stat_smooth(method = "lm", alpha = 0.7, aes(color = Variable),
    #          formula = y ~ poly(x, grad), se = FALSE) +
    facet_wrap(~Variable, scales = "free") +
    ggtitle(title)
}
# model delta
grid.arrange(
  plot_delta(mc, mp[1:nrow(mc), ], "MBCn Delta"),
  plot_delta(attr(vbc, "calibration"), vbc, "VBC Delta"),
  plot_delta(mbcn.c, mbcn.p[1:nrow(mc), ], "True Delta")
)

```


## 5 Fold CV

```{r, warning=FALSE, message=FALSE, eval=FALSE, echo=FALSE}
# Split your data into 5 folds
folds <- createFolds(cccma$rcm.c[ ,1], k = 8, list = TRUE, returnTrain = TRUE)


# Train and test your model on each fold
cv_eval = mclapply(1:8, function(i){
  # Get the training and testing data for this fold
  train_data <- cccma$rcm.c[folds[[i]], ]
  test_data <- cccma$rcm.c[-folds[[i]], ]
  
  # Correct vine
  vine_corrected <- vine_correct(train_data, mc, mp,
                                 margins_controls = m_control, 
                                 copula_controls = c_control)
  
  train_svine = rvine(nrow(train_data), attr(vbc, "vine_oc"))
  test_svine = rvine(nrow(test_data), attr(vbc, "vine_oc"))
  train_mvine = vine_corrected[sample(nrow(vine_corrected), nrow(train_data)),]
  test_mvine = vine_corrected[sample(nrow(vine_corrected), nrow(test_data)),]
  
  tplan_sv_train = transport(pp(train_svine), pp(train_data))
  tplan_sv_test = transport(pp(test_svine), pp(test_data))
  tplan_mv_train = transport(pp(train_mvine), pp(train_data))
  tplan_mv_test = transport(pp(test_mvine), pp(test_data))
  
  # Correct by MCBn
  mbcn_corrected <- MBCn(o.c=train_data, m.c=cccma$gcm.c,
                         m.p=cccma$gcm.p, ratio.seq=cccma$ratio.seq,
                         trace=cccma$trace, iter = 30, silent = TRUE)
  mbcnc <- mbcn_corrected$mhat.c
  
  train_mbcnc = mbcnc[sample(nrow(mbcnc), nrow(train_data)),]
  test_mbcnc = mbcnc[sample(nrow(mbcnc), nrow(test_data)),]
  
  tplan_mbcn_train = transport(pp(train_mbcnc), pp(train_data))
  tplan_mbcn_test = transport(pp(test_mbcnc), pp(test_data))
  
  
  ubc = mapply(QDM, o.c = data.frame(train_data), m.c = data.frame(mc), m.p = data.frame(mp),
           ratio=cccma$ratio.seq, trace=cccma$trace)
  ubc = do.call(cbind, ubc["mhat.p",])
  r2d2_BC = r2d2(train_data, ubc)
  r2d2_bc= r2d2_BC$r2d2_bc
  
  train_r2d2 = r2d2_bc[sample(nrow(r2d2_bc), nrow(train_data)),]
  test_r2d2 = r2d2_bc[sample(nrow(r2d2_bc), nrow(test_data)),]
  
  tplan_r2d2_train = transport(pp(train_r2d2), pp(train_data))
  tplan_r2d2_test = transport(pp(test_r2d2), pp(test_data))
  
    c(
      "r2d2_train_emd" = wasserstein(pp(train_r2d2), pp(train_data), p = 1, tplan = tplan_r2d2_train),
    "r2d2_test_emd" = wasserstein(pp(test_r2d2), pp(test_data), p = 1, tplan = tplan_r2d2_test),
    "r2d2_train_wasserstein2" = wasserstein(pp(train_r2d2), pp(train_data), p = 2, tplan = tplan_r2d2_train),
    "r2d2_test_wasserstein2" = wasserstein(pp(test_r2d2), pp(test_data), p = 2, tplan = tplan_r2d2_test),
    "vbc sample_train_emd" = wasserstein(pp(train_svine), pp(train_data), p = 1, tplan = tplan_sv_train),
    "vbc sample_test_emd" = wasserstein(pp(test_svine), pp(test_data), p = 1, tplan = tplan_sv_test),
    "vbc sample_train_wasserstein2" = wasserstein(pp(train_svine), pp(train_data), p = 2, tplan = tplan_sv_train),
    "vbc sample_test_wasserstein2" = wasserstein(pp(test_svine), pp(test_data), p = 2, tplan = tplan_sv_test),
    "vbc mapping_train_emd" = wasserstein(pp(train_mvine), pp(train_data), p = 1, tplan = tplan_mv_train),
    "vbc mapping_test_emd" = wasserstein(pp(test_mvine), pp(test_data), p = 1, tplan = tplan_mv_test),
    "vbc mapping_train_wasserstein2" = wasserstein(pp(train_mvine), pp(train_data), p = 2, tplan = tplan_mv_train),
    "vbc mapping_test_wasserstein2" = wasserstein(pp(test_mvine), pp(test_data), p = 2, tplan = tplan_mv_test),
    "MBCn cal_train_emd" = wasserstein(pp(train_mbcnc), pp(train_data), p = 1, tplan = tplan_mbcn_train),
    "MBCn cal_test_emd" = wasserstein(pp(test_mbcnc), pp(test_data), p = 1, tplan = tplan_mbcn_test),
    "MBCn cal_train_wasserstein2" = wasserstein(pp(train_mbcnc), pp(train_data), p = 2, tplan = tplan_mbcn_train),
    "MBCn cal_test_wasserstein2" = wasserstein(pp(test_mbcnc), pp(test_data), p = 2, tplan = tplan_mbcn_test)
  )
}, mc.cores = getOption("mc.cores", 8L))
saveRDS(cv_eval, file = "test_data.RDS")
```

```{r}
cv_eval = readRDS("test_data.RDS")

data.table::rbindlist(lapply(cv_eval,  function(x) as.data.frame(t(x)))) %>%
  gather(key = "Method",value = "Score") %>%
  separate(Method, c("Method", "Data_Set", "Metric"), sep = "_") %>%
  ggplot(aes(y = Score, x = Method, color = Data_Set)) +
  geom_boxplot() +
  facet_wrap(~Metric) +
  ggtitle("8 Fold CV", subtitle = "Evaluating the distance between bias corrected data\n and a measured test data set") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```
