time_mp = time_index)
# Apply vbc without time for comparison
set.seed(111)
result_no_time <- vbc(mp_dt, mc_dt, rc_dt)
# The result with time should include a "time" column as the last column
expect_true("time" %in% colnames(result_time))
expect_equal(result_time$time, time_index)
# The addition of time should not alter the corrected values of other columns
expect_equal(result_time[, .SD, .SDcols = c("x", "y")], result_no_time, ignore_attr = TRUE)
})
load_all()
set.seed(111)
n <- 50
# Simple dummy data with two variables
rc_dt <- data.table(x = runif(n), y = runif(n), z = runif(n))
mc_dt <- data.table(x = runif(n), y = runif(n), z = runif(n))
mp_dt <- data.table(x = runif(n), y = runif(n), z = runif(n))
# Create a time index vector for the projection period
time_index <- seq.Date(from = as.Date("2000-01-01"), by = "day", length.out = n)
#margins_controls <- list(type = rep("c", 3), xmin = rep(0, 3))
# Apply vbc with time_mp argument
set.seed(111)
result_time <- vbc(mp_dt, mc_dt, rc_dt, margins_controls = margins_controls,
time_mp = time_index)
if(ncol(mp != length(margins_controls[["type"]]))) {
margins_controls <- expand_margin_controls(margins_controls, mp)
}
load_all()
set.seed(111)
n <- 50
# Simple dummy data with two variables
rc_dt <- data.table(x = runif(n), y = runif(n), z = runif(n))
mc_dt <- data.table(x = runif(n), y = runif(n), z = runif(n))
mp_dt <- data.table(x = runif(n), y = runif(n), z = runif(n))
# Create a time index vector for the projection period
time_index <- seq.Date(from = as.Date("2000-01-01"), by = "day", length.out = n)
#margins_controls <- list(type = rep("c", 3), xmin = rep(0, 3))
# Apply vbc with time_mp argument
set.seed(111)
result_time <- vbc(mp_dt, mc_dt, rc_dt, margins_controls = margins_controls,
time_mp = time_index)
# Apply vbc without time for comparison
set.seed(111)
result_no_time <- vbc(mp_dt, mc_dt, rc_dt)
# The result with time should include a "time" column as the last column
expect_true("time" %in% colnames(result_time))
expect_equal(result_time$time, time_index)
# The addition of time should not alter the corrected values of other columns
expect_equal(result_time[, .SD, .SDcols = c("x", "y")], result_no_time, ignore_attr = TRUE)
# The addition of time should not alter the corrected values of other columns
expect_equal(result_time[, .SD, .SDcols = c("x", "y", "z")],
result_no_time, ignore_attr = TRUE, tolerance = 1e-1)
# The addition of time should not alter the corrected values of other columns
expect_equal(result_time[, .SD, .SDcols = c("x", "y", "z")],
result_no_time, ignore_attr = TRUE, tolerance = 0.2)
set.seed(222)
n <- 30
set.seed(222)
n <- 30
# Simulate dummy data for a calibration set and two ensemble projection members
rc_dt <- data.table(val = rnorm(n))
mc_dt <- data.table(val = rnorm(n))
mp1 <- data.table(val = rnorm(n, mean = 1))
mp2 <- data.table(val = rnorm(n, mean = 2))
mp_list <- list(mp1, mp2)
mp_list
# Simulate dummy data for a calibration set and two ensemble projection members
rc_dt <- data.table(val = rnorm(n))
mc_dt <- data.table(val = rnorm(n))
mp1 <- data.table(val = rnorm(n, mean = 1))
mp2 <- data.table(val = rnorm(n, mean = 2))
mp_list <- list(mp1, mp2)
# Correct both ensemble members in one call
set.seed(222)
result_list <- vbc(mp_list, mc_dt, rc_dt)
result_list <- vbc(mp_list, mc_dt, rc_dt)
debugonce(vbc)
result_list <- vbc(mp_list, mc_dt, rc_dt)
debugonce(vbc)
result_list <- vbc(mp_list, mc_dt, rc_dt)
get(type)
var(type)
set.seed(444)
# Create rc and mc with different number of variables to induce an error
rc_dt <- data.table(one = rnorm(5), two = rnorm(5))
mc_dt <- data.table(one = rnorm(5))  # mc has only one column, mismatch with rc
mp_dt <- data.table(one = rnorm(5))
# Expect an error due to mismatched number of columns (variables)
expect_error(vbc(mp_dt, mc_dt, rc_dt), regexp = "number of climate variables", ignore.case = TRUE)
# Expect an error due to mismatched number of columns (variables)
expect_error(vbc(mp_dt, mc_dt, rc_dt), regexp = "Musthave exactly", ignore.case = TRUE)
# Expect an error due to mismatched number of columns (variables)
expect_error(vbc(mp_dt, mc_dt, rc_dt), ignore.case = TRUE)
devtools::document()
devtools::spell_check()
compute_pseudo_obs
rvinecopulib:::compute_pseudo_obs
devtools::document()
devtools::document()
library(data.table)
library(ggplot2)
library(knitr)
library(patchwork)
#library(VBC)
data("climate")
climate_2010 = lapply(climate, function(data) data[year(time) == 2010, ])
devtools::load_all()
plot_tails(climate_2010$mp, "pr", scale_d = 0.1, mult = 4, xmin = 0) +
labs(x = "", title = "Marginal distribution of uncorrected model data") +
theme(legend.position = "none") +
plot_tails(climate_2010$rp, "pr", scale_d = 1, mult = 4, xmin = 0) +
labs(x = "precipitation (mm/h)",
title = "Marginal targeted distribution of reference data") +
scale_y_continuous(name = "") +
plot_layout(ncol = 1)
wd_pre = calc_wasserstein(climate_2010$mp[, "pr"], climate_2010$rp[, "pr"])
wd_pre
margins_controls <- list(xmin = c(NaN, 0, NaN, 0, 0),
type = c("c", "zi", "c", "zi", "c"))
mp_vbc = vbc(mp = climate_2010$mp[, -"time"], mc = climate_2010$mp[, -"time"],
rc = climate_2010$rp[, -"time"],
margins_controls = margins_controls, family_set = "tll",
trunc_lvl = Inf)
library(knitr)
opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "90%",
fig.align = "center",
dpi = 300
)
library(data.table)
library(ggplot2)
library(knitr)
library(patchwork)
#library(VBC)
data("climate")
climate_2010 = lapply(climate, function(data) data[year(time) == 2010, ])
devtools::load_all()
plot_tails(climate_2010$mp, "pr", scale_d = 0.1, mult = 4, xmin = 0) +
labs(x = "", title = "Marginal distribution of uncorrected model data") +
theme(legend.position = "none") +
plot_tails(climate_2010$rp, "pr", scale_d = 1, mult = 4, xmin = 0) +
labs(x = "precipitation (mm/h)",
title = "Marginal targeted distribution of reference data") +
scale_y_continuous(name = "") +
plot_layout(ncol = 1)
wd_pre = calc_wasserstein(climate_2010$mp[, "pr"], climate_2010$rp[, "pr"])
wd_pre
margins_controls <- list(xmin = c(NaN, 0, NaN, 0, 0),
type = c("c", "zi", "c", "zi", "c"))
mp_vbc = vbc(mp = climate_2010$mp[, -"time"], mc = climate_2010$mp[, -"time"],
rc = climate_2010$rp[, -"time"],
margins_controls = margins_controls, family_set = "tll",
trunc_lvl = Inf)
plot_tails(round(mp_vbc, 3), "pr", scale_d = 1, mult = 3, xmin = 0) +
labs(x = "precipitation (mm/h)",
title = "Marginal distribution of corrected model data")
wd_post = calc_wasserstein(climate_2010$rp[, "pr"], mp_vbc[, "pr"])
kable(data.frame("Wasserstein_Uncorrected" = wd_pre,
"Wasserstein_Corrected" = wd_post,
"Improvement" = wd_pre - wd_post,
"Improvement_in_Perc" = (wd_pre - wd_post) / wd_pre * 100),
digits = 2)
document()
document()
test_coverage()
test()
set.seed(1)
n <- 20
rc <- data.table(x = rnorm(n))
mc <- data.table(x = rnorm(n, 1))
mp <- data.table(x = rnorm(n, 2))
time <- seq_len(n)
# Apply vbc_tsub with a single time index
result <- vbc_tsub(mp, mc, rc, time_mp = time, tsub = c(1:10))
vbc_tsub
# Apply vbc_tsub with a single time index
result <- vbc_tsub(mp, mc, rc, time_mp = time, tsub = list(c(1:10)))
test()
set.seed(10)
n   <- 24 * 15  # ~15 days hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
tm
n   <- 6 * 15  # ~15 days 6 hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
n   <- 6 * 15  # ~15 days 6 hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
tm
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(month = 1, hour = 0:6))
tm
month(tm)
hour(tm)
n   <- 24 * 15  # ~15 days 6 hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(month = 1, hour = 0:6))
tm
debugonce(vbc_tsub)
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(month = 1, hour = 0:6))
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(list(month = 1, hour = 0:6)))
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(list(month = 1, hour = 0:6)))
debugonce(vbc_tsub)
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(list(month = 1, hour = 0:6)))
t_subs
load_all()
library(data.table)
set.seed(10)
n   <- 24 * 15  # ~15 days 6 hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(list(month = 1, hour = 0:6)))
load_all()
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(list(month = 1, hour = 0:6)))
library(data.table)
set.seed(10)
n   <- 24 * 15  # ~15 days 6 hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 2))
mp  <- data.table(x = rnorm(n, 3))
# Ensure each table has a POSIXct 'time' column
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
time_mp = tm,
tsub = list(list(month = 1, hour = 0:6)))
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
t_subs = list(list(month = 1, hour = 0:6)))
load_all()
library(data.table)
set.seed(10)
n   <- 24 * 15  # ~15 days 6 hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 2))
mp  <- data.table(x = rnorm(n, 3))
# Ensure each table has a POSIXct 'time' column
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
t_subs = list(list(month = 1, hour = 0:6)))
rc
mp  <- data.table(x = rnorm(n, 3), y = rnorm(n, 4))
set.seed(10)
n   <- 24 * 15  # ~15 days 6 hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
rc  <- data.table(x = rnorm(n), y = rnorm(n, 1))
mc  <- data.table(x = rnorm(n, 2), y = rnorm(n, 3))
mp  <- data.table(x = rnorm(n, 3), y = rnorm(n, 4))
# Ensure each table has a POSIXct 'time' column
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
t_subs = list(list(month = 1, hours = 0:6)))
expect_s3_class(out, "data.table")
expect_true(all(c("x", "time") %in% names(out)))
# only hours 0..6 in January
expect_true(all(as.integer(format(out$time, "%m")) == 1L))
expect_true(all(as.integer(format(out$time, "%H")) %in% 0:6))
test_that("vbc_tsub errors on empty selection (no times match)", {
library(data.table)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, time_mp = tm, tsub = list(month = 1, hour = 0:6)),
regexp = "empty|no.*match|must not be empty", ignore.case = TRUE
)
})
test()
library(devtools)
test()
set.seed(1)
rc <- data.table(x = 1:5, y = 1:5)
mp <- copy(rc) # perfectly concordant
mci_val <- MCI(rc, mp)
set.seed(1)
rc <- data.table(x = 1:5, y = 1:5)
mp <- copy(rc) # perfectly concordant
mci_val <- calc_mci(rc, mp)
mci_val
expect_equal(mci_val, 1) # perfect concordance
expect_equal(mci_val, 0) # perfect concordance
mci_val
expect_equal(mci_val$mci, 0) # perfect concordance
expect_equal(mci_val$mci, rep(0, 5) # perfect concordance
mp2 <- data.table(x = 1:5, y = 5:1) # perfectly discordant
expect_equal(mci_val$mci, rep(0, 5)) # perfect concordance
mp2 <- data.table(x = 1:5, y = 5:1) # perfectly discordant
mci_val2 <- calc_mci(rc, mp2)
mci_val2
mp2 <- data.table(x = 5:1, y = 5:1) # perfectly discordant
mci_val2 <- calc_mci(rc, mp2)
mci_val2
rc <- data.frame(x = 1:5)
mp <- data.frame(x = 1:5)
dist_same <- calc_wasserstein(rc, mp)
expect_equal(unname(dist_same["Wasserstein_1"]), 0)
expect_equal(unname(dist_same["Wasserstein_2"]), 0)
mp_shift <- data.frame(x = 2:6)
dist_shift <- calc_wasserstein(rc, mp_shift)
expect_equal(unname(dist_shift["Wasserstein_1"]), 1, tolerance = 1e-8)
expect_equal(unname(dist_shift["Wasserstein_2"]), 1, tolerance = 1e-8)
test()
test_that("vbc_tsub subsets by month and hour on single table", {
library(data.table)
set.seed(10)
n   <- 24 * 15  # ~15 days 6 hourly
tm  <- as.POSIXct("2010-01-01 00:00:00", tz = "UTC") + 3600 * seq_len(n)
rc  <- data.table(x = rnorm(n), y = rnorm(n, 1))
mc  <- data.table(x = rnorm(n, 2), y = rnorm(n, 3))
mp  <- data.table(x = rnorm(n, 3), y = rnorm(n, 4))
# Ensure each table has a POSIXct 'time' column
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# choose January (1) and early hours 0..6
out <- vbc_tsub(mp, mc, rc,
t_subs = list(list(month = 1, hours = 0:6)))
expect_s3_class(out, "data.table")
expect_true(all(c("x", "time") %in% names(out)))
# only hours 0..6 in January
expect_true(all(as.integer(format(out$time, "%m")) == 1L))
expect_true(all(as.integer(format(out$time, "%H")) %in% 0:6))
})
test_that("vbc_tsub errors on empty selection (no times match)", {
library(data.table)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, time_mp = tm, tsub = list(month = 1, hour = 0:6)),
regexp = "empty|no.*match|must not be empty", ignore.case = TRUE
)
})
library(data.table)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, time_mp = tm, tsub = list(month = 1, hour = 0:6))
)
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, time_mp = tm, tsub = list(month = 1, hour = 0:6))
)
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, tsub = list(list(month = 1, hours = 0:6)))
)
load_all()
library(data.table)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, tsub = list(list(month = 1, hours = 0:6)))
)
vbc_tsub(mp, mc, rc, tsub = list(list(month = 1, hours = 0:6)))
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
)
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
mp  <- data.table(x = rnorm(n, 2))
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
)
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
tm
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
library(data.table)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
)
library(devtools)
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
)
library(testthat)
library(data.table)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
)
library(data.table)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
)
test_that("vbc_tsub errors on empty selection (no times match)", {
library(data.table)
set.seed(11)
n   <- 24 * 5
tm  <- as.POSIXct("2010-02-01 00:00:00", tz = "UTC") + 3600 * seq_len(n) # February
rc  <- data.table(x = rnorm(n))
mc  <- data.table(x = rnorm(n, 1))
mp  <- data.table(x = rnorm(n, 2))
if (!"time" %in% names(rc)) rc[, time := tm]
if (!"time" %in% names(mc)) mc[, time := tm]
if (!"time" %in% names(mp)) mp[, time := tm]
# Ask for January hours in a February series -> empty
expect_error(
vbc_tsub(mp, mc, rc, t_subs = list(list(month = 1, hours = 0:6)))
)
})
