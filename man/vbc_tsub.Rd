% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vbc_tsub.R
\name{vbc_tsub}
\alias{vbc_tsub}
\title{Combine VBC and the Method of fragments}
\usage{
vbc_tsub(
  mp,
  mc,
  rc,
  var_names = colnames(rc),
  margins_controls = list(mult = NULL, xmin = NaN, xmax = NaN, bw = NA, deg = 2, type =
    "c"),
  t_subs = list(list(hours = 0:23, month = 1:12)),
  overlap = 1,
  cores_t = NA,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{mp}{\link{data.table}\cr
Simulation data from a climate model during projection period.
Expects one column time in \code{lubridate}-readable format.}

\item{mc}{\link{data.table}\cr
Simulation data from a climate model during calibration period.
Expects one column time in \code{lubridate}-readable format.}

\item{rc}{\link{data.table}\cr
Measured (and interpolated) observations during calibration period.
Expects one column time in \code{lubridate}-readable format.}

\item{var_names}{\link{character}\cr
Names of corrected climate data. Defaults to the column names of the
observed data \code{rc}.}

\item{margins_controls}{\link{list}\cr
A list with arguments to be passed to \code{\link[kde1d:kde1d]{kde1d::kde1d()}}. Currently, there can be
\itemize{
\item \code{mult} numeric vector of length one or d; all bandwidths for marginal
kernel density estimation are multiplied with \code{mult}. Defaults to
\code{log(1 + d)} where \code{d} is the number of climate variables.
\item \code{xmin} numeric vector of length d; see \code{\link[kde1d:kde1d]{kde1d::kde1d()}}.
\item \code{xmax} numeric vector of length d; see \code{\link[kde1d:kde1d]{kde1d::kde1d()}}.
\item \code{bw} numeric vector of length d; see \code{\link[kde1d:kde1d]{kde1d::kde1d()}}.
\item \code{deg} numeric vector of length one or d; \code{\link[kde1d:kde1d]{kde1d::kde1d()}}.
\item \code{type} character vector of length one or d; must be one of
c, cont, continuous for continuous variables, one of d, disc, discrete for
discrete integer variables, or one of zi, zinfl, zero-inflated for
zero-inflated variables.
}}

\item{t_subs}{\link{list}\cr
A list of two lists: hours and month. Each list contains the temporal
indicators to subset the data. The first list contains the hours of the day
the length of list marks the number of fragments. The inner list contains the
hour and monthly information to subset the data.}

\item{overlap}{\link{integer}\cr
The number of times to overlap the temporal indicators.}

\item{cores_t}{\link{integer}\cr
The number of cores to use for parallel processing of the temporal
subsetting. Default is \code{NA} which means no parallel processing.}

\item{verbose}{\link{logical}\cr
Print messages during the temporal subsetting.}

\item{...}{\cr
Arguments are passed to \link[rvinecopulib:vinecop]{rvinecopulib::vinecop} to specify the structure of
vines and margins. Note that the ellipsis of observed and model data are
specified with the same arguments.}
}
\value{
\link{data.table}\cr
The corrected projection period data in \code{mp}. Additionally the data frame
contains the attribute \code{mvd} with one list per temporal subset. In each
subset \code{vine_rc}, \code{kde_rc}, \code{vine_mp}, and \code{kde_mp} which store the
vine copula and kernel density estimation objects of the observed and model
data. The time column is attached to the data.
}
\description{
Combine VBC and the Method of fragments
}
\examples{
#' \dontrun{
#' data("climate")
#' climate_sub = lapply(climate, function(x) x[, c("pr", "tas", "dew", "time")])
#' margins_controls = list(xmin = c(0, NaN, NaN), type = c("zi", "c", "c"))
#' t_subs = list(day = list(hours = c(6, 9, 12, 15), month = 1:12),
#'               night = list(hours = c(18, 21, 0, 3), month = 1:12))
#' mp_vbc = vbc_tsub(climate_sub$rc, climate_sub$mc, climate_sub$mp,
#'                   t_subs = t_subs, margins_controls = margins_controls,
#'                   family_set = "tll", trunc_lvl = Inf)
#' class(mp_vbc)
#' attr(mp_vbc, "mvd")
#' 
#' calc_mci(climate_sub$mp[, -"time"], mp_vbc[, -"time"],
#'          time = climate$mp$time, margins_controls = margins_controls,
#'          family_set = "tll", trunc_lvl = Inf)
#' rbind(
#'  uncorrected = calc_wasserstein(climate_sub$rp[1:5000, -"time"],
#'                                 climate_sub$mp[1:5000, -"time"]),
#'  corrected = calc_wasserstein(climate_sub$rp[1:5000, -"time"],
#'                               mp_vbc[1:5000, -"time"])
#' )
#' }
}
\references{
Sharma, A.; Srikanthan, S. (2006): Continuous Rainfall Simulation:
A Nonparametric Alternative. In: 30th Hydrology and Water Resources
Symposium 4-7 December 2006, Launceston, Tasmania.

Westra, S.; Mehrotra, R.; Sharma, A.; Srikanthan, R. (2012): Continuous
rainfall simulation. 1. A regionalized subdaily disaggregation approach.
In: Water Resour. Res. 48 (1). DOI: 10.1029/2011WR010489.
}
